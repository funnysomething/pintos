# Project 1: Threads

## Preliminaries

>Fill in your name and email address.

FirstName LastName <email@domain.example>

>If you have any preliminary comments on your submission, notes for the
>TAs, please give them here.



>Please cite any offline or online sources you consulted while
>preparing your submission, other than the Pintos documentation, course
>text, lecture notes, and course staff.


## Debugging

#### QUESTIONS: BIOS 

>A1: What is the first instruction that gets executed?



>A2: At which physical address is this instruction located?




#### QUESTIONS: BOOTLOADER

>A3: How does the bootloader read disk sectors? In particular, what BIOS interrupt is used?



>A4: How does the bootloader decides whether it successfully finds the Pintos kernel?



>A5: What happens when the bootloader could not find the Pintos kernel?



>A6: At what point and how exactly does the bootloader transfer control to the Pintos kernel?



#### QUESTIONS: KERNEL

>A7: At the entry of pintos_init(), what is the value of expression `init_page_dir[pd_no(ptov(0))]` in hexadecimal format?



>A8: When `palloc_get_page()` is called for the first time,

>> A8.1 what does the call stack look like?
>>
>> 

>> A8.2 what is the return value in hexadecimal format?
>>
>> 

>> A8.3 what is the value of expression `init_page_dir[pd_no(ptov(0))]` in hexadecimal format?
>>
>> 



>A9: When palloc_get_page() is called for the third time,

>> A9.1 what does the call stack look like?
>>
>> 

>> A9.2 what is the return value in hexadecimal format?
>>
>> 

>> A9.3 what is the value of expression `init_page_dir[pd_no(ptov(0))]` in hexadecimal format?
>>
>> 



## Kernel Monitor

>B1: Put the screenshot of your kernel monitor running example here. (It should show how your kernel shell respond to `whoami`, `exit`, and `other input`.)

#### 

>B2: Explain how you read and write to the console for the kernel monitor.


## Alarm Clock

#### DATA STRUCTURES

>C1: Copy here the declaration of each new or changed struct or struct member, global or static variable, typedef, or enumeration.  Identify the purpose of each in 25 words or less.

`static struct list sleep_queue;`

Ordered queue of threads that are currently sleeping. Threads in it are ordered by wakeup time.

`struct list_elem sleepelem;` (added to struct thread)

Added to allow threads to be added to a list for use in waking them up.

`int64_t wakeup_time;`

Added to keep track of wakeup time of sleeping threads in ticks in the queue. Also used to order threads within the sleep queue


#### ALGORITHMS

>C2: Briefly describe what happens in a call to timer_sleep(),
>including the effects of the timer interrupt handler.

First we get the current tick count and assert that interrupts are on. Then we disable interrupts, calculate the wakeup time of the current thread (in ticks), and add it to sleep_queue. Then we block the current thread, and re-enable interrupts.

In the timer interrupt handler, we disable interrupts, then try removing things from sleep_queue that need to wakeup. Then we re-enable interrupts and call thread_tick()

>C3: What steps are taken to minimize the amount of time spent in
>the timer interrupt handler?

We optimized the data structure to allow the interrupt handler to take the least amount of steps required. The sleep_queue is implemented as an ordered list, so the thread with the soonest wakeup time will be at the front. This means if the front of the list isn't ready to waken yet, the interrupt handler doesn't need to do anything because it's guaranteed that nothing behind will need to wakeup.

#### SYNCHRONIZATION

>C4: How are race conditions avoided when multiple threads call
>timer_sleep() simultaneously?

We disable all interrupts before adding to the sleep queue, so if a thread starts the process it is guaranteed to finish it without any interruptions.

>C5: How are race conditions avoided when a timer interrupt occurs
>during a call to timer_sleep()?

Same as above.

i dont think this implementation is correct. look into synch.h. left a note in timer.c about this too.

#### RATIONALE

>C6: Why did you choose this design?  In what ways is it superior to
>another design you considered?



## Priority Scheduling

#### DATA STRUCTURES

>D1: Copy here the declaration of each new or changed struct or struct member, global or static variable, typedef, or enumeration.  Identify the purpose of each in 25 words or less.



>D2: Explain the data structure used to track priority donation.
>Use ASCII art to diagram a nested donation.  (Alternately, submit a
>.png file.)



#### ALGORITHMS

>D3: How do you ensure that the highest priority thread waiting for
>a lock, semaphore, or condition variable wakes up first?



>D4: Describe the sequence of events when a call to lock_acquire()
>causes a priority donation.  How is nested donation handled?



>D5: Describe the sequence of events when lock_release() is called
>on a lock that a higher-priority thread is waiting for.



#### SYNCHRONIZATION

>D6: Describe a potential race in thread_set_priority() and explain
>how your implementation avoids it.  Can you use a lock to avoid
>this race?



#### RATIONALE

>D7: Why did you choose this design?  In what ways is it superior to
>another design you considered?



## Advanced Scheduler

#### DATA STRUCTURES

>E1: Copy here the declaration of each new or changed struct or struct member, global or static variable, typedef, or enumeration.  Identify the purpose of each in 25 words or less.



#### ALGORITHMS

>E2: How is the way you divided the cost of scheduling between code
>inside and outside interrupt context likely to affect performance?



#### RATIONALE

>E3: Briefly critique your design, pointing out advantages and
>disadvantages in your design choices.  If you were to have extra
>time to work on this part of the project, how might you choose to
>refine or improve your design?



>E4: The assignment explains arithmetic for fixed-point math in
>detail, but it leaves it open to you to implement it.  Why did you
>decide to implement it the way you did?  If you created an
>abstraction layer for fixed-point math, that is, an abstract data
>type and/or a set of functions or macros to manipulate fixed-point
>numbers, why did you do so?  If not, why not?
